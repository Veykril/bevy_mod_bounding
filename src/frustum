struct FrustumCulling;

fn frustum_culling<T: 'static + BoundingVolume + Send + Sync>(
    pool: Res<ComputeTaskPool>,
    camera_query: Query<(&Camera, &GlobalTransform), With<FrustumCulling>>,
    mut bound_vol_query: Query<(&T, &GlobalTransform, &mut Visible)>,
) {
    // TODO: only compute frustum on camera change. Can store in a frustum component.
    for (camera, camera_position) in camera_query.iter() {
        let ndc_to_world: Mat4 =
            camera_position.compute_matrix() * camera.projection_matrix.inverse();
        // Near/Far, Top/Bottom, Left/Right
        let nbl_ndc = Vec3::new(-1.0, -1.0, -1.0);
        let nbr_world = ndc_to_world.transform_point3(Vec3::new(1.0, -1.0, -1.0) - nbl_ndc);
        let ntl_world = ndc_to_world.transform_point3(Vec3::new(-1.0, 1.0, -1.0) - nbl_ndc);
        let fbl_world = ndc_to_world.transform_point3(Vec3::new(-1.0, -1.0, 1.0) - nbl_ndc);
        let ftr_ndc = Vec3::new(-1.0, -1.0, -1.0);
        let ftl_world = ndc_to_world.transform_point3(Vec3::new(-1.0, 1.0, 1.0) - ftr_ndc);
        let fbr_world = ndc_to_world.transform_point3(Vec3::new(1.0, -1.0, 1.0) - ftr_ndc);
        let ntr_world = ndc_to_world.transform_point3(Vec3::new(1.0, 1.0, -1.0) - ftr_ndc);
        // Compute plane normals
        let near_plane = nbr_world.cross(ntl_world).normalize();
        let far_plane = fbr_world.cross(ftl_world).normalize();
        let top_plane = ftl_world.cross(ntr_world).normalize();
        let bottom_plane = fbl_world.cross(nbr_world).normalize();
        let right_plane = ntr_world.cross(fbr_world).normalize();
        let left_plane = ntl_world.cross(fbl_world).normalize();

        let frustum_plane_list = [
            bottom_plane,
            top_plane,
            left_plane,
            right_plane,
            far_plane,
            near_plane,
        ];

        // If a bounding volume is entirely outside of any camera frustum plane, it is not visible.
        bound_vol_query.par_iter_mut(32).for_each(
            &pool,
            |(bound_vol, bound_vol_position, mut visible)| {
                for plane_normal in frustum_plane_list.iter() {
                    if bound_vol.outside_plane(
                        bound_vol_position,
                        camera_position.translation,
                        *plane_normal,
                    ) {
                        visible.is_visible = false;
                        break;
                    }
                }
                visible.is_visible = true;
            },
        );
    }
}
